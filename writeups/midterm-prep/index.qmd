---
title: "Midterm Prep Practice Problems"
date: last-modified
categories:
  - "Extra Writeups"
format:
  html:
    df-print: kable
    cache: false
metadata-files: 
  - ../../_doc-meta.yml
---

::: {.callout-tip title="Update Log"}

* *2023-10-14, 11pm EST*: Added overview of **object-oriented programming in Python**, along with a practice problem on this topic.
* *2023-10-14, 10pm EST*: Initial version of document, emailed out in announcement to students.

:::

This writeup is organized so that each section represents a particular topic/subtopic that the exam may cover, such that the example problems within each topic/subtopic will prepare you for questions on that topic/subtopic which may appear on the midterm!

## Data Science Fundamentals

### Filepaths

For these practice problems, assume we have a directory structure on our computer that looks as follows, and that **this is the entire directory structure** (that is, there are no additional files or folders on the computer that are not displayed in the diagram).

```{dot}
digraph G {
    rankdir="TB"
    node[shape="plaintext",fontname="Courier New"];
    "nodeRoot" [
        label=<<table>
        <tr>
          <td border="0"><b>/</b></td>
        </tr>
        <tr>
          <td>file1.txt</td>
        </tr>
        <tr>
          <td>file2.txt</td>
        </tr>
        <tr>
          <td>rootImage.jpg</td>
        </tr>
        </table>>
    ];
    "nodeUsers" [
        label=<<table>
        <tr>
          <td border="0"><b>Users</b></td>
        </tr>
        </table>>
    ];
    "nodeApps" [
        label=<<table>
        <tr>
          <td border="0"><b>Applications</b></td>
        </tr>
        <tr>
          <td>App1.app</td>
        </tr>
        <tr>
          <td>App2.app</td>
        </tr>
        <tr>
          <td>appImage.png</td>
        </tr>
        </table>>
    ];
    "nodeJeff" [
        label=<<table>
        <tr>
          <td border="0"><b>jpj</b></td>
        </tr>
        <tr>
          <td>doc1.qmd</td>
        </tr>
        <tr>
          <td>doc2.qmd</td>
        </tr>
        <tr>
          <td>jeffImage.jpeg</td>
        </tr>
        </table>>
    ];
    nodeRoot -> nodeUsers;
    nodeRoot -> nodeApps;
    nodeUsers -> nodeJeff;
}
```

The way this diagram works is:

* The **names of folders** are bolded, and if a **folder** `X` is contained within a folder `Y`, then the diagram has an arrow between folder `X` and folder `Y`.
    * So, for example, since the **Users** folder here is a subfolder of the **/** folder (the *root folder*), there is an arrow pointing from the box with label **/** to the box with label **Users**.
* If a **file** `f` is contained within a folder, then the file is displayed as a box within the box representing the folder.
    * So, for example, since the document `doc1.qmd` is contained within the folder labeled **`jpj`**, there is a smaller box labeled `doc1.qmd` within the box labeled **`jpj`**.

Please answer the following questions, with reference to this directory structure:

1. **True** or **False**: If I am writing the document `doc1.qmd`, and I want to include the image `jeffImage.jpeg` from within the same folder, I can use the **relative path** `jeffImage.jpeg`, like

    ```
    ![Photo caption](jeffImage.jpeg)
    ```

::: {.callout-note collapse="true" title="Solution (Click to expand)"}

**True**: Since `jeffImage.jpeg` is in the same directory as the `.qmd` file we're authoring, we can reference it using a relative path to the file which is actually just the name of the file (since the Quarto compiler doesn't need to navigate to any other folder to retrieve the file).
:::

2. **True** or **False**: If I am writing the document `doc1.qmd`, and I want to include the image `jeffImage.jpeg` from within the same folder, I can use the **absolute path** `/Users/jpj/jeffImage.jpeg`, like

    ```
    ![Photo caption](/Users/jpj/jeffImage.jpeg)
    ```

::: {.callout-note collapse="true" title="Solution (Click to expand)"}

**True**: In this case, it actually doesn't matter where the `.qmd` file we're authoring exists on the filesystem, since we're using an **absolute path**. This means that, no matter where the `.qmd` file is, the Quarto compiler will be able to find the image file, by starting at the root directory `/`, navigating to the `Users` subdirectory, then the `jpj` subdirectory, and finally locating the `jeffImage.jpeg` file within this `jpj` subdirectory.
:::

3. **True** or **False**: If I am writing the document `doc1.qmd`, and I want to include the image `jeffImage.jpeg` from within the same folder, I can use the **relative path** `images/jeffImage.jpeg`, like

    ```
    ![Photo caption](images/jeffImage.jpeg)
    ```

::: {.callout-note collapse="true" title="Solution (Click to expand)"}

**False**: In this case, the Quarto compiler will crash with an error. It will attempt to look for an `images` subdirectory within the directory where the `.qmd` file is located, and it will not find a subdirectory called `images` (since there are no subdirectories within the `jpj` folder), producing an error.
:::

### HTTP

Please match each of the following **HTTP codes** on the left to their **meanings** on the right (that is, what it means if we receive that code as a response to our call to the server):

::: {layout="[1,2]"}

| | HTTP Code |
| - | - |
| 1 | 200 |
| 2 | 301 |
| 3 | 403 |
| 3 | 404 |
| 4 | 500 |

| | Meaning |
| - | - |
| A | Error: the server software could not find the requested file or data |
| B | Successful request (the body of the request should thus contain the html code, or json data, or whatever else was requested) |
| C | Server error: the server software crashed or experienced an error while trying to respond to the request |
| D | Not authorized: the requested file is protected by a password that was not given correctly, for example, or it is restricted only to logged-in users and the user making the request was not logged in. |
| E | Redirect: A response with this code indicates that the server is going to redirect the user to a different page within the website, or a different website entirely. |

: {tbl-colwidths="[10,90]"}

:::

::: {.callout-note collapse="true" title="Solution (Click to expand)"}

1. **B**. 200 is the HTTP code for a **successful request**
2. **E**. 301 is the HTTP code for a **redirect**
3. **D**. 403 is the HTTP code for a **non-authorized** request
4. **A**. 404 is the HTTP code for **file not found**
5. **C**. 500 is the HTTP code for an **unknown/unspecified server error**
:::

### Git/GitHub

[From [Week 04 Slides](../../w04/index.qmd){target='_blank'}] Please match each of the following `git` commands with the description of what it does:

::: {layout="[1,2]"}

| | Command |
| - | - |
| 1 | `git clone` |
| 2 | `git init` |
| 3 | `git add` |
| 4 | `git reset` |
| 5 | `git status` |
| 6 | `git commit -m "message"` |
| 7 | `git push` |
| 8 | `git pull` |
| 9 | `git merge` |

| | Description |
| - | - |
| A | Downloads a repo from the web to our local computer |
| B | Creates a new, blank Git repository on our local computer (configuration/change-tracking stored in `.git` subfolder) |
| C | **Stages** a file(s): Git will now track changes in this file(s) |
| D | Undoes a `git add` |
| E | Shows currently staged files and their status (created, modified, deleted) |
| F | "Saves" the current version of all staged files, ready to be pushed to a backup dir or remote server like GitHub |
| G | Transmits local commits to remote server |
| H | Downloads commits from remote server to local computer |
| I | Merges remote versions of files with local versions |

: {tbl-colwidths="[1,2]"}

:::

::: {.callout-note collapse="true" title="Solution (Click to expand)"}

1. **B**. 200 is the HTTP code for a **successful request**
2. **E**. 301 is the HTTP code for a **redirect**
3. **D**. 403 is the HTTP code for a **non-authorized** request
4. **A**. 404 is the HTTP code for **file not found**
5. **C**. 500 is the HTTP code for an **unknown/unspecified server error**
:::

### Python: Object-Oriented Programming (Overview)

We didn't get to talk about this much in class, so here I will give a quick overview and then a practice problem afterwards.

The way that <a href='https://en.wikipedia.org/wiki/Object-oriented_programming' target='_blank'>Object-Oriented Programming</a> is implemented in Python is as follows:

Python provides you with a set of "default" object types: starting from the base <a href='https://docs.python.org/3/library/functions.html#object' target='_blank'>`object` class</a>, for example, it provides classes like `int`, `float`, `string`, `boolean`, and so on.

However, sometimes these base classes on their own, or combinations of them, cannot serve the purposes that you need for your particular project/application. In these cases, you can create your own **custom classes**, with syntax that looks like the following

*(**NOTE**: Despite the fact that we're not explicitly defining `Vehicle` here to be a sub-class of any other class, **by default** in Python **all classes are subclasses of the `object` class mentioned above**)*

```{python}
class Vehicle:
    def __init__(self, maker, num_wheels):
        self.maker = maker
        self.num_wheels = num_wheels
```

By defining the class using the line `class Vehicle` at the top, and then defining a **constructor function** called `__init__()`, we can now create new objects with the **type** `Vehicle` by using syntax like the following:

```{python}
my_vehicle = Vehicle("Toyota", 4)
```

Which will call the `__init__()` function defined above, such that now the value `"Toyota"` will be stored in the **instance variable** called `maker` within the `my_car` object, and the value `4` will be stored in the instance variable called `num_wheels` within the `my_obj` object. The **object** `my_obj` here is therefore an **instance** of the class `Vehicle`.

This means that, from this point onwards, we can access this information (the values contained in `maker` and `num_wheels`) using the **dot operator** `.` on the object, like:

```{python}
print(my_vehicle.maker, my_vehicle.num_wheels)
```

Now that we've seen how to define a **class**, providing a **template** for creating objects, and how to **create objects** using the **constructor function** within a **class**, let's now look at the notion of **inheritance**.

**An issue with OOP in *Python* (unlike many other languages) is that Python does *not* allow you to create multiple versions of the same function within the same class**.

This means, for example, that we could **not** add a `start_vehicle()` function to our `Vehicle` class which would behave differently given different input types. The following new version of `Vehicle` will produce an error:

```{python}
class Vehicle:
    def __init__(self, maker, num_wheels):
        self.maker = maker
        self.num_wheels = num_wheels
    
    def start_vehicle(self):
        """
        Version for cars
        """
        # Start the car

    def start_vehicle(self):
        """
        Version for motorcycles
        """
        # Start the motorcycle
```

So, if we find ourselves in a case where we want to model a **hierarchy** of more-general to more-specific versions of a class, we can use **inheritance** to define **sub-classes** of a given class which represent a more specific "version" of this class.

So, using our `Vehicle` class as our working example, we may find ourselves defining **four-wheeled** vehicles very often, since **cars** are common vehicles which always have four wheels, but also **two-wheeled** vehicles very often, since **motorcycles** are common vehicles which always have two wheels.

So, to make our lives easier, rather than having to specify the number of wheels each time we want to create an object representing a car or motorcycle, instead we can create **sub-classes** of `Vehicle` representing cars and motorcycles, as follows:

```{python}
class Car(Vehicle):
    def __init__(self, maker):
        super().__init__(maker, 4)

class Motorcycle(Vehicle):
    def __init__(self, maker):
        super().__init__(maker, 2)
```

Now that we have these two sub-classes, defined in this way, we can create **`Car`** and **`Motorcycle`** objects, which will have those types (`Car` and `Motorcycle`, respectively) but will **also** both have type `Vehicle`, and will have their `num_wheels` value set automatically, without us having to provide these values explicitly to the `Car` and/or `Motorcycle` constructors:

```{python}
my_car = Car("Toyota")
my_motorcycle = Motorcycle("Kawasaki")
```

And now, despite the fact that `my_car` and `my_motorcycle` are of different sub-types, since they are both objects of type `Vehicle` we know that we can access a field called `num_wheels` on both:

```{python}
print(my_car.num_wheels, my_motorcycle.num_wheels)
```

So, we can see from this output that `num_wheels` has been set correctly, automatically, despite the fact that we did not explicitly specify the values `4` or `2` when creating our `my_car` and `my_motorcycle` objects above.

### Python: Object-Oriented Programming (Practice Problem)

Given the above overview, hopefully the following practice problem becomes more manageable!

**Fill in the blanks to make the statement correct, by choosing the correct answer from each dropdown menu**:

```{=html}
Defining a <select name="cars" id="cars" style="display: inline-block">
  <option value="answer1">class</option>
  <option value="answer2">string</option>
</select> in Python (which should include a constructor function with the name <select name="cars2" id="cars2" style="display: inline-block"><option value="answer1">__init__()</option><option value="answer2">__start__()</option><option value="answer3">__letsgooo__()</option></select>), allows us to create <b>objects</b>, each of which is <select><option value="answer1">an instance</option><option value="answer1">a version</option></select> of the class.
```

### Conda

### Typecasting

## Steps in the Data Science Pipeline

### Data Gathering

### Data Cleaning

* Long to wide, wide to long

### EDA

## Text Analysis

* How to go from corpus -> DTM

## Machine Learning

* Distance metrics
* Precision, recall, F1-score
* Loss functions: MSE, RMSE, MAE
* Supervised, unsupervised, reinforcement learning
    * Buzzwords: classes, label, binary classification, multiclass classification, scalar regression, vector regressions
* Confusion matrix
* Overfitting
* KNN for classification and/or regression