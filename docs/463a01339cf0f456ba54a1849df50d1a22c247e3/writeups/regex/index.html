<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-09-26">

<title>DSAN 5000 – index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ETYTX4E16L"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-ETYTX4E16L', { 'anonymize_ip': true});
</script>
<script src="https://code.jquery.com/jquery-3.7.1.slim.min.js"></script><script src="../../jjcustom.js"></script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#pythons-re-library" id="toc-pythons-re-library" class="nav-link active" data-scroll-target="#pythons-re-library">Python’s <code>re</code> Library</a></li>
  <li><a href="#pythons-r-syntax" id="toc-pythons-r-syntax" class="nav-link" data-scroll-target="#pythons-r-syntax">Python’s <code>r''</code> Syntax</a>
  <ul class="collapse">
  <li><a href="#re.compile" id="toc-re.compile" class="nav-link" data-scroll-target="#re.compile"><code>re.compile()</code></a></li>
  </ul></li>
  <li><a href="#binary-accept-vs.-reject-match" id="toc-binary-accept-vs.-reject-match" class="nav-link" data-scroll-target="#binary-accept-vs.-reject-match">Binary Accept vs.&nbsp;Reject: <code>match()</code></a></li>
  <li><a href="#searching-a-string-for-matches" id="toc-searching-a-string-for-matches" class="nav-link" data-scroll-target="#searching-a-string-for-matches">Searching a String for Matches</a></li>
  <li><a href="#smart-substitution-sub" id="toc-smart-substitution-sub" class="nav-link" data-scroll-target="#smart-substitution-sub">Smart Substitution: <code>sub()</code></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Regular Expressions for Data Cleaning</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Extra Writeups</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 26, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Since my <a href="../../writeups/data-cleaning/clean_data.html" target="_blank">Data Cleaning with Python</a> video did not end up using regular expressions as part of the data cleaning process, in this writeup I want to quickly show you examples of how learning regular expressions can make your life 1000x easier when cleaning any data involving <strong>string</strong> variables.</p>
<section id="pythons-re-library" class="level2">
<h2 class="anchored" data-anchor-id="pythons-re-library">Python’s <code>re</code> Library</h2>
<p>Since regular expressions are the key building block for how programming language compilers/interpreters actually figure out what your code is telling it to do, most languages have a regular expression library built-in, and Python is no exception! To load Python’s regular expression library, you can add the following line of code to the top of your Python file/notebook:</p>
<div id="import-re" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="pythons-r-syntax" class="level2">
<h2 class="anchored" data-anchor-id="pythons-r-syntax">Python’s <code>r''</code> Syntax</h2>
<p>Although regular expressions are ordinary <strong>string</strong> objects in Python, we’re using them in a different way from how we use ordinary strings: While you’ve seen ordinary <em>non</em>-RegEx strings like <code>s = "Hello"</code>, <code>x = "abc123"</code>, regular expressions are a bit confusing relative to these types of strings, since we’re using them as a sort of “meta-language” to search for <strong>patterns within other strings</strong>.</p>
<p>This means, for example, that if we include the special character <code>\t</code> in a <strong>RegEx string</strong>, Python knows to interpret this as “I am looking for a tab character” rather than “Place four spaces here” as it would be interpreted in an ordinary non-RegEx string. To accomplish this separation, Python allows you to prefix regular expression strings with the letter <code>r</code>, like</p>
<div id="regex-prefix" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ordinary_string <span class="op">=</span> <span class="st">"Hello</span><span class="ch">\t</span><span class="st">World"</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>regex_string <span class="op">=</span> <span class="vs">r'Hello\tWorld'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So that now if we print the two strings we can see the difference:</p>
<div id="regex-string-printing" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ordinary_string)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(regex_string)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This will become important as you start to use regular expressions to clean data: for example, if you happen to come across a dataset in <code>.tsv</code> format, and you want to convert it into <code>.csv</code> so it is more consistently read and displayed across different Operating Systems, you can use the following RegEx pattern to find all of the <code>\t</code> characters and replace them with a comma (we will learn about each of the functions I’m using here in the sections below, so don’t worry if you don’t understand what’s happening here for the moment):</p>
<div id="regex-tsv-example" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>original_file <span class="op">=</span> <span class="st">"""id</span><span class="ch">\t</span><span class="st">var1</span><span class="ch">\t</span><span class="st">var2</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="st">0</span><span class="ch">\t</span><span class="st">Jeff</span><span class="ch">\t</span><span class="st">5</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="st">1</span><span class="ch">\t</span><span class="st">James</span><span class="ch">\t</span><span class="st">6</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="st">2</span><span class="ch">\t</span><span class="st">Nakul</span><span class="ch">\t</span><span class="st">7"""</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>tab_regex_str <span class="op">=</span> <span class="vs">r'\t'</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>tab_regex <span class="op">=</span> re.<span class="bu">compile</span>(tab_regex_str)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>cleaned_file <span class="op">=</span> tab_regex.sub(<span class="st">","</span>, original_file)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cleaned_file)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once the library is imported, although there are lots of functions you could use, the following are the main ones you will use for data cleaning:</p>
<section id="re.compile" class="level3">
<h3 class="anchored" data-anchor-id="re.compile"><code>re.compile()</code></h3>
<p>Long story short, although you could <em>technically</em> get away with using all the features of the <code>re</code> library without <strong>compiling</strong> your regular expression strings, I <strong>highly recommend</strong> always converting a “raw” regular expression string into a compiled <code>re</code> object, since compiling your RegEx string into a compiled object will make all the remaining functions run much faster.</p>
<p>In the above <code>.tsv</code>-to-<code>.csv</code> example, we took the raw RegEx string <code>tab_regex_str</code> and <strong>compiled it</strong> using <code>tab_regex = re.compile(tab_regex_str)</code>, so that we could then use <code>tab_regex</code> as a regular expression <strong>object</strong> with all of the RegEx-related Pythons callable using the <code>.</code> operator:</p>
<div id="compiled-regex-functions" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>match_result <span class="op">=</span> tab_regex.match(original_file)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(match_result)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>search_result <span class="op">=</span> tab_regex.search(original_file)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(search_result)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>findall_result <span class="op">=</span> tab_regex.findall(original_file)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(findall_result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If, for whatever reason, you don’t want to compile your RegEx strings, you can still call all of these functions by using the <code>re</code> module directly and providing a RegEx string as the first argument to the function, like</p>
<div id="non-compiled-regex-functions" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>match_result_nocompile <span class="op">=</span> re.match(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    tab_regex_str,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    original_file</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(match_result)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>search_result_nocompile <span class="op">=</span> re.search(tab_regex_str, original_file)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(search_result)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>findall_result_nocompile <span class="op">=</span> re.findall(tab_regex_str, original_file)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(findall_result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Since I want you to get in the habit of <strong>compiling</strong> your regular expression strings, I’m going to use the object-specific syntax (e.g., <code>my_compiled_regex.match()</code>) rather than the global syntax (<code>re.match()</code>), for this and all remaining functions.</p>
<p>Now let’s look at what each of these three functions does!</p>
</section>
</section>
<section id="binary-accept-vs.-reject-match" class="level2">
<h2 class="anchored" data-anchor-id="binary-accept-vs.-reject-match">Binary Accept vs.&nbsp;Reject: <code>match()</code></h2>
<p>You can think of <code>match()</code> as associated with the <strong>original</strong> purpose of regular expressions: to take in a string and <strong>accept</strong> or <strong>reject</strong> that string based on whether or not it matches the pattern described by the regular expression (see <a href="../../w05/index.html" target="_blank">Week 05</a> for examples). This function will return <strong>information on the match</strong> if the match was <strong>successful</strong>, or the Python “null” value <code>None</code> otherwise<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>In the above examples, we saw that in fact our RegEx string did <strong>not</strong> match the provided string <code>original_file</code>: this is the expected behavior, and makes sense, since <code>.match()</code> will only be successful if <strong>the provided string EXACTLY matches the provided regular expression</strong>. Since <code>original_file</code> was a whole file, with lots of different characters, the regular expression <code>r'\t'</code> (which matches only a <strong>single</strong> <code>\t</code> character) will not match the file. The only string that our RegEx pattern <code>r'\t'</code> would actually perfectly match would be the string <code>"\t"</code>:</p>
<div id="match-tab-character" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>single_tab_character <span class="op">=</span> <span class="st">"</span><span class="ch">\t</span><span class="st">"</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tab_regex.match(single_tab_character))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>But, even adding a single additional character before the <code>\t</code> will cause this RegEx string to no longer match<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
<div id="match-two-characters" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>two_characters <span class="op">=</span> <span class="st">"s</span><span class="ch">\t</span><span class="st">"</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tab_regex.match(two_characters))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This can be extremely helpful when you want to (for example) validate a column in a dataset, like a phone number column: if you write a phone number RegEx string, you can use it in conjunction with <code>match()</code> and Pandas to check that <strong>every string in the column is a match</strong>:</p>
<div id="match-phone-numbers" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>phone_reg_str <span class="op">=</span> <span class="vs">r'[0-9]</span><span class="sc">{3}</span><span class="vs">-[0-9]</span><span class="sc">{3}</span><span class="vs">-[0-9]</span><span class="sc">{4}</span><span class="vs">'</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>phone_reg <span class="op">=</span> re.<span class="bu">compile</span>(phone_reg_str)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>number_list <span class="op">=</span> [<span class="st">'202-123-4567'</span>,<span class="st">'202-999-9999'</span>,<span class="st">'301x123x1234'</span>]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>phone_df <span class="op">=</span> pd.DataFrame({<span class="st">'phone_num'</span>: number_list})</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>phone_df[<span class="st">'match'</span>] <span class="op">=</span> phone_df[<span class="st">'phone_num'</span>].<span class="bu">apply</span>(phone_reg.match)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>phone_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Although I do tend to just store the <code>.match()</code> result in a column like this, while cleaning, if you’re going to <strong>export</strong> the dataset it’s a bit sloppy to just put the <code>re.match</code> object itself into a column like this (it may cause issues if you try to save it as <code>.csv</code> and load it on a different operating system, for example). So, a cleaner version safe for export could look like:</p>
<div id="match-column" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>phone_df[<span class="st">'match'</span>] <span class="op">=</span> phone_df[<span class="st">'phone_num'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: phone_reg.match(x) <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>phone_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="searching-a-string-for-matches" class="level2">
<h2 class="anchored" data-anchor-id="searching-a-string-for-matches">Searching a String for Matches</h2>
<p>The <code>findall()</code> function, unlike <code>match()</code>, does <strong>not</strong> require that the entire string is matched by the RegEx pattern. Instead, it finds <strong>all substrings within the bigger string</strong> that match the pattern (put another way: all the substrings for which <code>re.match()</code> would return a match).</p>
<p>This is helpful in a different data cleaning case, where for example you may have <strong>freeform text</strong> and you want to <strong>extract</strong> all of the phone numbers written in this freeform text. For example: Imagine a dataset containing the results from a <strong>survey</strong> with a freeform text field like “Introduce Yourself!”, and you want to go through this field and extract all of the phone numbers that have been entered in this field:</p>
<div id="extract-phone-numbers" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>responses <span class="op">=</span> [</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Hello my number is 202-123-4567"</span>,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Hi thanks for the survey call me at 301-111-1111 or 925-123-1111"</span>,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"I hate this survey don't ever call 240-999-9999"</span>,</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"I don't have a phone number sorry"</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>survey_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'response'</span>: responses</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>survey_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can run the the <code>findall()</code> function on each entry in the <code>response</code> column here, to extract just the phone numbers:</p>
<div id="cell-24" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>survey_df[<span class="st">'matches'</span>] <span class="op">=</span> survey_df[<span class="st">'response'</span>].<span class="bu">apply</span>(phone_reg.findall)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>survey_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note the fact that <code>findall()</code> returns a <strong>list</strong> of matches, rather than just one match, so that if you’re expecting only one you’ll have to handle the case of multiple matches (like in row 2 of this example) as well as the case of no matches (row 4).</p>
</section>
<section id="smart-substitution-sub" class="level2">
<h2 class="anchored" data-anchor-id="smart-substitution-sub">Smart Substitution: <code>sub()</code></h2>
<p>Oftentimes you’re not worried about analyzing the <code>re.match</code> objects themselves, you just want to use a RegEx to do a fancier <strong>find and replace</strong> than what’s possible using <code>.replace(x,y)</code> (the Python string function that finds all instances of <code>x</code> in a string and replaces them with <code>y</code>).</p>
<p>For example, in the <a href="../../writeups/data-cleaning/clean_data.html" target="_blank">Data Cleaning with Python</a> video/writeup, I found that one of the counties in one dataset did not match with the same county in the other dataset, because in one the county name was abbreviate to <code>St. Mary's</code> while in the other the name was fully written out as <code>Saint Mary's</code>.</p>
<p>In that case, I was able to just use <code>.replace()</code>, since there was only one instance and I knew exactly what I wanted to replace with what. But, for a trickier case that regular expressions can handle while <code>.replace()</code> can’t, image merging one dataset where two-character abbreviations like this are followed by a period like <code>St. Marys</code>, with another dataset where two-character abbreviations are <strong>not</strong> followed by a period, like <code>St Marys</code> (this is actually fairly common, as sometimes names like this are entered into old database systems used by government agencies that don’t allow entering commas and/or apostrophes).</p>
<p>To handle this, we can write code using regular expressions that finds <strong>all two-letter abbreviations</strong>—portions of a string starting with a capital letter, followed by a lowercase letter, followed by a period—and replaces them with the same string but without the period at the end.</p>
<div id="cell-26" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>abbrev_reg_str <span class="op">=</span> <span class="vs">r'[A-Z][a-z]\.'</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>abbrev_reg <span class="op">=</span> re.<span class="bu">compile</span>(abbrev_reg_str)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>county_list <span class="op">=</span> [</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'St. Marys'</span>,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Ft. Worth'</span>,</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Montgomery'</span>,</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Mt. Everest'</span>,</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Mt. St. Vincent'</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>county_df <span class="op">=</span> pd.DataFrame({<span class="st">'name'</span>: county_list})</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>county_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Like before, we can use <code>abbrev_reg.findall()</code> to find instances of this type of abbreviation across the dataset:</p>
<div id="cell-28" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>county_df[<span class="st">'matches'</span>] <span class="op">=</span> county_df[<span class="st">'name'</span>].<span class="bu">apply</span>(abbrev_reg.findall)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>county_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>However, to be able to <strong>automatically replace</strong> the matches with a given replacement, we’ll have to dive one level deeper into regular expressions. I will talk about this more in lecture, but it boils down to: you can use <strong>parentheses</strong> within your regular expression to indicate <strong>match groups</strong>: subsets of the regular expression that you would like <code>re</code> to keep track of when it finds a match, and then provide a <strong>replacement string</strong> that utilizes these match groups. It is easier to explain through example than through text. In the following code, we use <strong>match groups</strong> to indicate to Python that we want to extract just the <strong>country code</strong> from an entire phone number:</p>
<div id="cell-30" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>area_code_reg_str <span class="op">=</span> <span class="vs">r'(?P&lt;county_code&gt;[+][0-9]{1,3})-[0-9]</span><span class="sc">{3}</span><span class="vs">-[0-9]</span><span class="sc">{3}</span><span class="vs">-[0-9]</span><span class="sc">{4}</span><span class="vs">'</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>area_code_reg <span class="op">=</span> re.<span class="bu">compile</span>(area_code_reg_str)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>my_num <span class="op">=</span> <span class="st">'+970-202-111-1111'</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>match_result <span class="op">=</span> area_code_reg.match(my_num)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(match_result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So, we see that we have a match, but we took the extra step of putting <strong>parentheses</strong> around the part of the match that we specifically wanted, and telling Python to call this part <code>county_code</code>, so now we can use the <code>.groupdict()</code> function of the <code>re.match</code> object to specifically extract just this <strong>subset</strong> of the full match:</p>
<div id="cell-32" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>match_result.groupdict()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can also directly use the captured groups within the <code>sub()</code> method, like</p>
<div id="cell-34" class="cell" data-vscode="{&quot;languageId&quot;:&quot;python&quot;}">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>area_code_reg.sub(<span class="vs">r'Country code \1'</span>, my_num)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>By applying this same logic to the abbreviation matches above, therefore, we</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>You have to be <strong>extremely careful</strong> when running RegEx functions (or any functions/libraries where functions can return <code>None</code>) in Jupyter notebooks for this reason: the way Jupyter is set up, if the last line of code in a cell has the value <code>None</code>, Jupyter just <strong>won’t display anything at all</strong> when you run that cell, even if the execution of the cell was totally successful (i.e., even if there were no errors). That’s why—as in the above examples—I try to remember to always <code>print()</code> the results of RegEx functions in Python, rather than just expecting Jupyter to automatically display their result.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>To reiterate the point about <code>None</code>: if hadn’t used <code>print()</code> in this case, to explicitly tell Jupyter to print the result of the last line, this cell wouldn’t have produced any output.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>